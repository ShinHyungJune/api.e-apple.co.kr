# 개수별로 출고 생성 작업계획보고서

**날짜**: 2025-10-17
**프로젝트**: api.e-apple.co.kr (열매나무 쇼핑몰 백엔드)
**작성자**: 개발팀

---

## 📋 작업 배경

### 현재 상황
- 고객이 과일 2개를 주문하면 → `order_products` 테이블에 1개 레코드 생성 (`quantity=2`)
- 출고관리 화면에서 해당 주문이 1개 행으로만 표시됨
- 2개를 각각 다른 택배로 보내거나 개별 출고 처리가 불가능함

### 문제점
- **과일은 개별 포장/개별 배송이 필요함**
- 현재는 2개를 하나로 묶어서만 처리 가능
- 1개는 출고하고 1개는 나중에 출고하는 것이 불가능
- 각 과일마다 다른 택배사/운송장 번호를 부여할 수 없음

### 요구사항
고객이 같은 상품 2개 주문 시:
- `order_products` 테이블에 2개 레코드 생성 (각각 `quantity=1`)
- 출고관리 화면에서 2개 행으로 표시
- 각각 개별적으로 출고 처리 가능

---

## 🎯 작업 목표

### 변경 전
| 주문내용 | orders | order_products |
|---------|--------|---------------|
| 사과 10kg 2개 | 1건 | 1건 (quantity=2) |

### 변경 후
| 주문내용 | orders | order_products |
|---------|--------|---------------|
| 사과 10kg 2개 | 1건 | **2건** (각각 quantity=1) |

---

## 🔍 분석 결과

### 1. 현재 주문 생성 플로우

#### A. 장바구니 주문 (`OrderController::cartsStore()`)
```php
// 1. 장바구니 상품옵션 조회
$cartProductOptions = CartProductOption::with(['productOption'])
    ->mine($request)
    ->whereIn('cart_id', $data['cart_ids'])
    ->get();

// 2. 주문 데이터 생성
$data = Order::getCartsData($data, $cartProductOptions);

// 3. Order::getCartsData() 내부
'order_products' => $cartProductOptions->map(function ($cartProductOption) use ($data) {
    return self::setOrderProducts([
        $data['status'],
        auth()->id() ?? null,
        $data['guest_id'] ?? null,
        $cartProductOption->productOption->product_id,
        $cartProductOption->productOption->id,
        $cartProductOption->quantity, // ← 여기가 문제! 2를 그대로 넘김
        $cartProductOption->productOption->price,
        $cartProductOption->productOption->original_price,
    ]);
})->toArray(),
```

**현재 동작**:
- 장바구니에 사과 2개 담김 → `CartProductOption` 1개 (quantity=2)
- `map()` 사용 → `OrderProduct` 1개 생성 (quantity=2)

#### B. 바로구매 (`OrderController::store()`)
```php
// OrderRequest::prepareForValidation()
foreach ($this->order_products as $k => $orderProduct) {
    $inputs['order_products'][$k] = Order::setOrderProducts([
        $inputs['status'], $inputs['user_id'], $inputs['guest_id'],
        $orderProduct['product_id'], $orderProduct['product_option_id'],
        $orderProduct['quantity'], // ← 여기도 문제!
        $orderProduct['price'],
        $productOptions[$orderProduct['product_option_id']]->original_price
    ]);
}
```

**현재 동작**:
- 프론트에서 `{quantity: 2}` 전송
- `OrderProduct` 1개 생성 (quantity=2)

---

### 2. 수정이 필요한 파일

#### 파일 1: `app/Models/Order.php`
**메서드**: `getCartsData()` (42-63번 라인)
**용도**: 장바구니 주문 시 OrderProduct 데이터 생성

#### 파일 2: `app/Http/Requests/OrderRequest.php`
**메서드**: `prepareForValidation()` (122-143번 라인)
**용도**: 바로구매 시 OrderProduct 데이터 생성

---

## 🛠️ 수정 계획

### 계획 1: 장바구니 주문 수정 (`Order::getCartsData()`)

#### 현재 코드
```php
'order_products' => $cartProductOptions->map(function ($cartProductOption) use ($data) {
    return self::setOrderProducts([
        // ... 생략 ...
        $cartProductOption->quantity, // 2를 그대로 저장
        // ... 생략 ...
    ]);
})->toArray(),
```

#### 수정 코드 (안)
```php
'order_products' => $cartProductOptions->flatMap(function ($cartProductOption) use ($data) {
    // 수량만큼 개별 OrderProduct 생성
    $orderProducts = [];
    for ($i = 0; $i < $cartProductOption->quantity; $i++) {
        $orderProducts[] = self::setOrderProducts([
            $data['status'],
            auth()->id() ?? null,
            $data['guest_id'] ?? null,
            $cartProductOption->productOption->product_id,
            $cartProductOption->productOption->id,
            1, // ← 항상 1로 변경
            $cartProductOption->productOption->price,
            $cartProductOption->productOption->original_price,
        ]);
    }
    return $orderProducts;
})->toArray(),
```

**변경 포인트**:
1. `map()` → `flatMap()` 변경 (다중 배열을 평탄화)
2. `for` 루프로 `quantity`만큼 반복
3. 각 OrderProduct의 `quantity`를 **항상 1**로 설정

---

### 계획 2: 바로구매 수정 (`OrderRequest::prepareForValidation()`)

#### 현재 코드
```php
foreach ($this->order_products as $k => $orderProduct) {
    $inputs['order_products'][$k] = Order::setOrderProducts([
        // ... 생략 ...
        $orderProduct['quantity'], // 수량 그대로 저장
        // ... 생략 ...
    ]);
}
```

#### 수정 코드 (안)
```php
$inputs['order_products'] = []; // 초기화

foreach ($this->order_products as $k => $orderProduct) {
    // 수량만큼 개별 OrderProduct 생성
    for ($i = 0; $i < $orderProduct['quantity']; $i++) {
        $inputs['order_products'][] = Order::setOrderProducts([
            $inputs['status'], $inputs['user_id'], $inputs['guest_id'],
            $orderProduct['product_id'], $orderProduct['product_option_id'],
            1, // ← 항상 1로 변경
            $orderProduct['price'],
            $productOptions[$orderProduct['product_option_id']]->original_price
        ]);
    }
}
```

**변경 포인트**:
1. `$inputs['order_products']` 배열 초기화
2. `for` 루프로 `quantity`만큼 반복
3. 인덱스 `[$k]` 대신 `[]`로 순차 추가
4. 각 OrderProduct의 `quantity`를 **항상 1**로 설정

---

## 📊 영향 범위 분석

### 1. 재고 처리 ✅
**파일**: `app/Models/Order.php`

#### 주문 완료 시 재고 감소 (335-337번 라인)
```php
$this->orderProducts->each(function ($e) {
    $e->productOption()->decrement('stock_quantity', $e->quantity);
});
```
- 기존: OrderProduct 1개 (quantity=2) → 재고 2 감소
- 변경: OrderProduct 2개 (각 quantity=1) → 재고 1씩 2번 감소 (총 2 감소)
- **영향 없음** ✅

#### 주문 취소 시 재고 복원 (375-377번 라인)
```php
$this->orderProducts->each(function ($e) {
    $e->productOption()->increment('stock_quantity', $e->quantity);
});
```
- **영향 없음** ✅

---

### 2. 가격 계산 ✅
**파일**: `app/Models/Order.php`

#### 주문 금액 검증 (99-110번 라인)
```php
$totalAmount = 0;
foreach ($orderProducts as $e) {
    $productOption = $productOptions->where('product_id', $e['product_id'])
        ->where('id', $e['product_option_id'])->first();
    $totalAmount += $productOption['price'] * $e['quantity'];
}
```
- 기존: 50,000 × 2 = 100,000원
- 변경: (50,000 × 1) + (50,000 × 1) = 100,000원
- **영향 없음** ✅

---

### 3. 출고 관리 ✅
**파일**: `app/Http/Controllers/Api/Admin/OrderProductController.php`

- 현재 출고관리는 OrderProduct 단위로 동작
- OrderProduct가 2개로 늘어나면 **출고관리에서 2개 행으로 표시됨**
- 각각 개별 출고 처리 가능
- **의도한 동작** ✅

---

### 4. 프론트엔드 영향 ⚠️

#### 주문 상세 페이지
- 기존: 사과 10kg (수량: 2) → 1개 행 표시
- 변경: 사과 10kg (수량: 1) → 2개 행 표시

**필요한 처리**:
- 같은 상품을 그룹핑하여 표시하고 싶다면 프론트엔드에서 처리 필요
- 또는 그냥 2개 행으로 표시

**예시 (Vue.js)**:
```javascript
computed: {
  groupedOrderProducts() {
    const grouped = {};
    this.orderProducts.forEach(op => {
      const key = op.product_option_id;
      if (!grouped[key]) {
        grouped[key] = { ...op, items: [], totalQty: 0 };
      }
      grouped[key].items.push(op);
      grouped[key].totalQty += op.quantity;
    });
    return Object.values(grouped);
  }
}
```

---

## ⚠️ 발견된 잠재적 버그

### 버그 의심: total_amount 계산

**위치**: `app/Models/Order.php:47`

**현재 코드**:
```php
'total_amount' => $cartProductOptions->sum(function ($cartProductOption) {
    return $cartProductOption->price * $cartProductOption->quantity;
    //     ^^^^^^^^^^^^^^^^^^^^^^^^ 의심스러움
}),
```

**의문점**:
- `$cartProductOption->price`라는 속성이 실제로 존재하는가?
- `CartProductOption` 모델은 `productOption` 관계만 있고 직접 `price`는 없는 것으로 보임
- 61번 라인에서는 `$cartProductOption->productOption->price`를 사용함

**확인 필요**:
1. `cart_product_options` 테이블 구조 확인
2. `price` 컬럼 존재 여부
3. 기존 장바구니 주문이 정상 동작했는지 확인

**수정 필요 시**:
```php
'total_amount' => $cartProductOptions->sum(function ($cartProductOption) {
    return $cartProductOption->productOption->price * $cartProductOption->quantity;
}),
```

---

## 🧪 테스트 계획

### 1. Unit 테스트
```php
// tests/Unit/OrderProductSplitTest.php

/** @test */
public function 수량2개_주문시_OrderProduct_2개_생성()
{
    // Given: 수량 2개
    // When: getCartsData() 호출
    // Then: OrderProduct 2개 생성됨 (각 quantity=1)
}

/** @test */
public function 재고처리_정상동작()
{
    // Given: OrderProduct 2개 (각 quantity=1)
    // When: 재고 감소/복원
    // Then: 총 2개 감소/복원
}

/** @test */
public function 가격계산_정상동작()
{
    // Given: OrderProduct 2개 (각 quantity=1, price=50000)
    // When: 총 금액 계산
    // Then: 100,000원
}
```

### 2. Feature 테스트
```php
// tests/Feature/OrderFlowTest.php

/** @test */
public function 장바구니_수량2개_주문_전체플로우()
{
    // Given: 장바구니에 사과 2개
    // When: 주문 생성 → 결제 완료
    // Then:
    //   - OrderProduct 2개 생성
    //   - 재고 2 감소
    //   - 출고관리에 2개 행 표시
}
```

### 3. 수동 테스트 시나리오
1. 장바구니에 사과 2개 담기
2. 주문하기
3. 결제 완료
4. 관리자 → 출고관리 → 2개 행 확인
5. 첫 번째만 출고 처리
6. 두 번째는 나중에 출고 처리
7. 주문 취소 → 재고 2개 복원 확인

---

## 📋 작업 순서

### Phase 1: 코드 수정
1. ✅ `app/Models/Order.php` - getCartsData() 수정
2. ✅ `app/Http/Requests/OrderRequest.php` - prepareForValidation() 수정
3. ⚠️ `app/Models/Order.php:47` - total_amount 버그 확인 및 수정 (필요 시)

### Phase 2: 테스트
1. Unit 테스트 작성 및 실행
2. Feature 테스트 작성 및 실행
3. 수동 테스트 (로컬 환경)

### Phase 3: 배포
1. 스테이징 환경 배포
2. QA 테스트
3. 프로덕션 배포
4. 모니터링

---

## 🚨 주의사항

### 1. 기존 주문 데이터
- **기존 주문 데이터는 변경되지 않음**
- 기존: `order_products`에 `quantity > 1`인 레코드 존재
- 신규: `order_products`에 `quantity = 1`만 생성됨
- **혼재 가능성 있음** (마이그레이션 불필요)

### 2. 데이터베이스 마이그레이션
- **불필요함**
- 테이블 구조 변경 없음
- 단순히 INSERT하는 레코드 개수만 증가

### 3. 성능 고려사항
- 수량이 많은 경우 (예: 100개) INSERT 성능 확인 필요
- `createMany()`를 사용하므로 대량 INSERT도 문제없을 것으로 예상

### 4. 롤백 계획
- Git으로 이전 버전으로 되돌리면 됨
- 데이터베이스 롤백 불필요

---

## 📝 후속 작업 제안

### 1. 프론트엔드 UI 개선
- 주문 상세 페이지에서 같은 상품 그룹핑 표시
- 출고관리에서 같은 주문의 상품들 시각적으로 구분

### 2. 배치 출고 기능
- 같은 주문의 여러 상품을 한 번에 출고 처리
- 같은 택배사/운송장으로 일괄 처리

### 3. 통계 조정
- 주문 통계 집계 시 `COUNT(order_products)`가 아닌 `SUM(quantity)` 사용 확인

---

## ✅ 체크리스트

### 작업 전 확인
- [ ] `cart_product_options` 테이블 구조 확인
- [ ] 기존 장바구니 주문 정상 동작 여부 확인
- [ ] total_amount 버그 존재 여부 확인

### 작업 중
- [ ] Order.php 수정
- [ ] OrderRequest.php 수정
- [ ] total_amount 버그 수정 (필요 시)
- [ ] Unit 테스트 작성
- [ ] Feature 테스트 작성

### 작업 후
- [ ] 로컬 환경 테스트
- [ ] 스테이징 환경 테스트
- [ ] 프론트엔드 UI 확인
- [ ] 출고관리 동작 확인
- [ ] 재고 처리 확인
- [ ] 프로덕션 배포
- [ ] 모니터링

---

## 📞 문의 및 협의 필요 사항

1. **CartProductOption.price 컬럼 존재 여부 확인 필요**
   - DB 담당자와 확인 필요

2. **기존 장바구니 주문 동작 확인**
   - 실제 운영 데이터로 테스트 필요

3. **프론트엔드 UI 그룹핑 여부 결정**
   - 기획자 / 디자이너와 협의 필요

4. **배포 일정 조율**
   - PM과 협의 필요

---

**작성일**: 2025-10-17
**최종 업데이트**: 2025-10-17
**작성자**: 개발팀
**검토자**: (TBD)
**승인자**: (TBD)
